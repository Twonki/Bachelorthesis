\section{Machine Learning im SQL-Server 2017}
\label{sec:MLSQL} \label{sec:MachineLearning}
Innerhalb dieses Abschnittes befinden sich Code-Beispiele zur Umsetzung der in Kapitel \ref{cha:Theorie} vorgestellten Algorithmen. 

Es werden im Folgenden kurz die Einbindung der R-Skripte in TSQL behandelt, anschließend werden nur die R-Skripte für die einzelnen Punkte erläutert.
\paragraph{Möglichkeiten in  R}
Die Sprache R besitzt verschiedene Optionen Machine-Learning Modelle zu erzeugen. Neben der Implementation \textit{von Grund auf} gibt es eine Vielzahl von Paketen und Bibliotheken. 

Für die lineare und logistische Regression werden die Bibliotheken \textit{RevoscaleR} und \textit{MicrosoftML} von Microsoft benutzt (Die Dokumentation findet sich unter \cite{RevoscaleR}). Sie wird bereits mit dem SQL-Server geliefert. Hauptargument für diese Umsetzung waren die gründliche Dokumentation von Microsoft, die eine Benutzung innerhalb des SQL-Servers bereits behandelt, sowie die gemeinsame Produktfamilie die einen einheitlichen Technik-Stack ergibt. 
\paragraph{Möglichkeiten in Python}
Der SQL-Server 2017 unterstützt neben einem R-Server ebenfalls eine Instanz des Microsoft ML-Servers. Dieses Open Source Projekt zu finden auf Github \cite{GithubMLServer} stellt eine Alternative zu den in R vorgestellten Methoden dar. 

Der ML-Server ist in Python implementiert und die Benutzung verhält sich ähnlich zu den Ansätzen von Tensorflow in Python. 

\paragraph{Verwendung von R im SQL-Server}
Um R im SQL-Server zu benutzen wird die Stored Procedure \textit{sp\_execute\_external\_script} benötigt. Im Folgenden ein einfaches Beispiel: ~\newline

\begin{lstlisting}[language=SQL]
	EXECUTE sp_execute_external_script
	@language = N'R',
	@script = N' 
		mytextvariable <- c("hello", " ", input_data);
		OutputDataSet <- as.data.frame(mytextvariable);',
	@input_data = N' SELECT name FROM readers'
	WITH RESULT SETS (([Greetings] char(20) NOT NULL));
\end{lstlisting}

Hierbei wird in Zeile 2 zunächst die Sprache als Parameter übergeben, in Zeile 4 wird innerhalb des R Skriptes ein Begrüßungs-String erstellt, welcher in Zeile 5 als Ausgabe wiedergeben wird.

In Zeile 6 wird die Inputvariable definiert, an dieser Stelle sind SQL Befehle und gültige T-SQL Variablen möglich. Es können beliebig viele Inputvariablen definiert werden. 

In Zeile 7 wird die Ausgabe in Tabellenform normiert. Diese Zeile ist nicht notwendig.  

~\newline Dieses Schema bleibt allen Skript-Aufrufen gleich. Im Folgenden werden nur die R-Skripte vorgestellt.
\subsection{Lineare Regression}
Für die diese Form der Regression gelten innerhalb des Paketes MicrosoftML folgende Bedingungen: ~\newline
\begin{enumerate}
	\item Alle Eingabewerte des Modells müssen (reelle)\footnote{Es gibt andere Pakete, die komplexe Zahlen unterstützen} Zahlen sein
	\item Texteingabewerte müssen zuvor über einen Faktor realisiert werden. Dieser Faktor muss eine festgesetzte Anzahl an Leveln besitzen. 
	\item Der Ausgabewerte ist eine reelle Zahl 
\end{enumerate}

Um ein Modell für die lineare Regression zu erstellen, sind in R nur wenige Zeilen notwendig: ~\newline
\begin{lstlisting}[language=R]
	formel <- C ~ A+B;
	model <- rxLinMod(formula=formel, data=TrainingsData);
	serializedModel <- data.frame(payload = as.raw(serialize(model, connection=null)));
\end{lstlisting}

In der ersten Zeile wird zunächst eine allgemeine Formel definiert. Diese Formel ist zu interpretieren als $f: (A~x~B)\rightarrow C $ , das '+' ist hierbei nicht als Addition zu verstehen.

In Zeile 2 wird das Modell mithilfe der Bibliothek RevoscaleR und dem Methodenaufruf rxLinMod erstellt \textbf{und} Trainiert. Als Parameter werden die Formel und die Trainingsdaten benötigt. 

In der dritten Zeile findet eine Serialisierung des Modells statt - dies ist nicht notwendig für eine direkte Verwendung, ermöglicht allerdings das speichern des Modells innerhalb des SQL-Servers als Blob.  

Um das Modell zu benutzen reichen ebenfalls wenige Zeilen R-Skript: \newline

\begin{lstlisting}[language=R]
	model <- unserialize(as.raw(serializedModel)); 
	C <- rxPredict(model,data.frame(TestData));
\end{lstlisting}

Hierbei wird zunächst in Zeile 1 das serialisierte Modell wieder nutzbar gemacht. 

In Zeile 2 wird die Methode \textit{rxPredict} der RevoScaleR-Bibliothek aufgerufen, welche aus den zu testenden Daten und dem Model eine Prognose erstellt. 
\subsection{Klassifikation}
Für die Klassifikation mit RevoscaleR gelten folgende Bedingungen: ~\newline

\begin{enumerate}
	\item Alle Eingabewerte des Modells sind reelle Zahlen.
	\item Texteingabewerte müssen zuvor über einen Faktor realisiert werden. Dieser Faktor muss eine festgesetzte Anzahl an Leveln besitzen.
	\item Die Klasse stellt einen Faktor mit Level 2 dar.
	\item Der Ausgabewerte ist eine Wahrscheinlichkeit, mit der die Ausprägung positiv ausfällt
	\item Es kann gleichzeitig nur eine Klasse überprüft werden
\end{enumerate}

Der R-Code verhält sich parallel zum Code der linearen Regression:

\begin{lstlisting}[language=R]
	formel <- rain ~ temperature+humidity;
	logitmodel <- rxLogit(formula = form, data = TrainingsData);
	rainPropability <- rxPredict(model, data.frame(TestData));
\end{lstlisting}

Als Beispiel wurde hierbei die Voraussage gewählt, ob es regnet anhand von Temperatur und Luftfeuchtigkeit.
\subsection{Neuronale Netze}
Es ist Möglich, die im Abschnitt \ref{sec:NN} vorgestellten Konzepte direkt in R umzusetzen. Ein gutes Tutorial liefert hierbei \cite{SelbyNN}, welcher eine Schritt-Für-Schritt Anleitung und Erklärung bietet ein eigenes Neuronales Netz zu entwerfen. Das Tutorial von Selby setzt einen ähnlichen Blogeintrag von Denny Britz (Siehe \cite{DennyNN}) in R um. 

Innerhalb dieser Arbeit wird allerdings das Paket \textit{MicrosoftML} verwendet.

\paragraph{Netz-Definition} ~\newline
Eine der wichtigsten Einstellung stellt die Definition des Neuronalen Netzes dar. Für diese wird innerhalb der Microsoft-Umgebung (Innerhalb des ML-Servers, Azure und R-Services) einheitlich eine Definition in \textit{Net\#} verwendet. Diese Notation definiert  das gesamte Neuronale Netz, und stellt einen einheitlichen und übertragbaren Standard in der Microsoft Umgebung dar. Ein einfaches Beispiel: ~\newline

\begin{lstlisting}[language=R]
 netDefinition <- ("
 	input Data auto;
 	hidden Hidden[25] sigmoid from Data all;
 	output Result[2] from Hidden all;  
 ")
\end{lstlisting}

In Zeile zwei wird die Eingabeschicht mit dem Namen \textit{Data} und einer automatisch-erkannten Größe erstellt. 

In Zeile drei wird die versteckte Schicht \textit{Hidden} mit 25 Knoten, einer Verbindung zu allen Knoten in Data und der Aktivierungsfunktion \textit{Sigmoid} gewählt. 

In Zeile vier wird die Ausgabeschicht \textit{Result} mit zwei Ausgabeknoten definiert. Es handelt sich um eine Binäre Klassifikation. Die Aktivierungsfunktion wird auf den Standardwert \textit{sigmoid} gesetzt. 

~\newline Es werden an ein neuronales Netzwerk innerhalb von net\# folgende Anforderungen gestellt:

\begin{itemize}
	\item Jedes neuronale Netz besitzt mindestens eine Eingabeschichte und genau eine Ausgabeschicht
	\item Die Anzahl der Knoten der Ausgabeschicht entspricht der Klasse des neuronalen Netzes (Ein Ausgabeknoten für Regression, zwei für Binäre Klassifikation, \textit{n} für eine Klassifikation von \textit{n-}Labeln)
	\item Verbindungen müssen azyklisch sein, anders ausgedrückt, sie dürfen keine Kette von Verbindungen bilden, die zurück zum ursprünglichen Quellknoten führen.
	\item Um eine Vorhersage mit dem Modell zu machen, werden bei den Eingabedaten mindestens alle in der Formel angegebenen Features benötigt. 
\end{itemize}

~\newline Nach diesem Schema lassen sich beliebig komplexe neuronale Netze definieren. Es gibt weitere Möglichkeiten, die Netzdefinition anzupassen:

\begin{itemize}
	\item Auswahl von Aktivierungsfunktionen (z.B. ReLU, Softmax, Linear)
	\item Deklaration Konvolutionsbündeln, d.h. Schichten definieren, welche sich mit zusätzlichen Gewichten gegenseitig beeinflussen
	\item Deklaration von Selektionsbündeln, d.h. Auswahlkriterien nach welchen die Schichten verknüpft werden
	\item Deklaration von Poolingbündeln, d.h. Schichten und Teilnetze, welche eine ähnliche Funktion erfüllen, allerdings nicht trainiert werden. 
\end{itemize} 

\paragraph{Regression} ~\newline
Ein neuronales Netz mithilfe des Paketes zu erstellen ist ähnlich einfach wie ein normales Modell hierfür:

\begin{lstlisting}[language=R]
netDefinition <- ("
	input Data auto;
	hidden Hidden[25] sigmoid from Data all;
	output Result[1] linear from Hidden all; ")
form <- C ~A+B;
model <- rxNeuralNet(
		formula = form, 
		data = TrainingsData,              
		type = "regression",
		netDefinition = netDefinition,
		numIterations = 100,
		normalize = "yes"
);
\end{lstlisting}

Zunächst wird ein Netz definiert, welches als Ausgabeschicht einen einzelnen Knoten mit linearer Ausgabefunktion besitzt. Anschließend wird die Formel aus dem obigen Beispiel für Lineare Regression definiert, und das Modell mit der Funktion \textit{rxNeuralNet(...)} erstellt. Diese erhält gegenüber anderen Modellen zusätzliche Parameter für die Netzdefinition, die Iterationen und den Typ des neuronalen Netzes. 

Des Weiteren können Einstellungen über die Optimierungsfunktion, Initialisierung der Gewichte, sowie Lerngeschwindigkeit, Verfall und Beschleunigung vorgenommen werden.

\paragraph{Multiclass-Labeling} ~\newline
Um eine Multiklassen-Klassifizerung vorzunehmen benötigt man einen ähnlichen Aufbau:


\begin{lstlisting}[language=R]
netDefinition <- ("
		input Picture auto;
		hidden Hidden[250] sigmoid from Picture all;
		output Species[4] softmax from Hidden all; ")
form <- Species ~Sepal.Length+Sepal.Width+Petal.Length+Petal+Width;

model <- rxNeuralNet(
		formula = form, 
		data = TrainingsData,              
		type = "multiclass",
		netDefinition = netDefinition
);
\end{lstlisting}

Als Beispiel ist die Klassifizierung eines Bildes in eine von 4 Lotus-Spezien gewählt. Zu betonen ist, das die Ausgabe der Vorhersage 5 Werte erzeugt: Einen für die wahrscheinlichste Spezies, und für jede Spezies die Wahrscheinlichkeit.